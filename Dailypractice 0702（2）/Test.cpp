// 题目：
// 猴子分桃
// 现有若干桃子，每只小猴子都把桃子平均分成5堆，但会多出来一个给老猴子，自己拿走其中的一堆。
// 现有n只小猴子，请计算出开始时至少有多少个桃子，以及最后老猴子至少得到多少个桃子。

// 解题：
// 假设最少需要x个桃子
// 第一次处理剩余桃子数目：4/5（x-1）= （4/5）× x - （4/5）
// 第二次处理剩余桃子数目：4/5（4/5（x-1）-1） = （（4/5）^ 2）× x - （（4/5）^ 2） - （4/5）
// 第 n次处理剩余桃子数目：（（4/5）^ n）× x）- （（4/5）^ n ）- （（4/5）^（n-1））- ... - （4/5）
// 最终公式：（X+4）*（4/5）^ n-4
// 保证最后剩余的桃子数最少且为整数，那么当 X+4 = 5^n 时，刚好满足要求

#include<iostream>
#include<cmath>
using namespace std;

int main(){
	long n;
	while (cin >> n){
		if (n == 0) break;
		long total = pow(5, n) - 4;
		long left = pow(4, n) + n - 4;
		cout << total << " " << left << endl;
	}
	return 0;
}